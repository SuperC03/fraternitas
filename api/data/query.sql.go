// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNonAdminUser = `-- name: CreateNonAdminUser :one
INSERT INTO "user" (
    "name", kerb, phone, department, class_year
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING kerb, is_admin, org_id, "name"
`

type CreateNonAdminUserParams struct {
	Name       pgtype.Text `json:"name"`
	Kerb       string      `json:"kerb"`
	Phone      pgtype.Text `json:"phone"`
	Department pgtype.Text `json:"department"`
	ClassYear  pgtype.Text `json:"class_year"`
}

type CreateNonAdminUserRow struct {
	Kerb    string      `json:"kerb"`
	IsAdmin bool        `json:"is_admin"`
	OrgID   pgtype.Int4 `json:"org_id"`
	Name    pgtype.Text `json:"name"`
}

func (q *Queries) CreateNonAdminUser(ctx context.Context, arg CreateNonAdminUserParams) (CreateNonAdminUserRow, error) {
	row := q.db.QueryRow(ctx, createNonAdminUser,
		arg.Name,
		arg.Kerb,
		arg.Phone,
		arg.Department,
		arg.ClassYear,
	)
	var i CreateNonAdminUserRow
	err := row.Scan(
		&i.Kerb,
		&i.IsAdmin,
		&i.OrgID,
		&i.Name,
	)
	return i, err
}

const getDatesOverview = `-- name: GetDatesOverview :many
SELECT DATE("start") FROM "event"
GROUP BY DATE("start") ORDER BY DATE("start")
`

func (q *Queries) GetDatesOverview(ctx context.Context) ([]pgtype.Date, error) {
	rows, err := q.db.Query(ctx, getDatesOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Date
	for rows.Next() {
		var date pgtype.Date
		if err := rows.Scan(&date); err != nil {
			return nil, err
		}
		items = append(items, date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatetimesOverview = `-- name: GetDatetimesOverview :many
SELECT "start" FROM "event"
GROUP BY "start"
`

func (q *Queries) GetDatetimesOverview(ctx context.Context) ([]pgtype.Timestamp, error) {
	rows, err := q.db.Query(ctx, getDatetimesOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Timestamp
	for rows.Next() {
		var start pgtype.Timestamp
		if err := rows.Scan(&start); err != nil {
			return nil, err
		}
		items = append(items, start)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventInformation = `-- name: GetEventInformation :one
SELECT "event".id, org_id, title, "start", "end", "description", "location", category, "organization"."name" as org_name FROM "event"
LEFT JOIN "organization" ON "event".org_id = "organization".id
WHERE "event".id = $1
LIMIT 1
`

type GetEventInformationRow struct {
	ID          int32            `json:"id"`
	OrgID       int32            `json:"org_id"`
	Title       string           `json:"title"`
	Start       pgtype.Timestamp `json:"start"`
	End         pgtype.Timestamp `json:"end"`
	Description pgtype.Text      `json:"description"`
	Location    pgtype.Text      `json:"location"`
	Category    pgtype.Text      `json:"category"`
	OrgName     pgtype.Text      `json:"org_name"`
}

func (q *Queries) GetEventInformation(ctx context.Context, id int32) (GetEventInformationRow, error) {
	row := q.db.QueryRow(ctx, getEventInformation, id)
	var i GetEventInformationRow
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Title,
		&i.Start,
		&i.End,
		&i.Description,
		&i.Location,
		&i.Category,
		&i.OrgName,
	)
	return i, err
}

const getEventsOverview = `-- name: GetEventsOverview :many
SELECT "event".id, org_id, title, "start", category, "organization".code AS "org_code" FROM "event"
LEFT JOIN "organization" ON "event".org_id = "organization".id
WHERE (
    (org_id = $1 OR $1 = 0) AND
    (category = $2::text OR $2 = '') AND
    (DATE(start) >= DATE($3::text) OR $3 IS NULL)
)
ORDER BY "start" ASC
`

type GetEventsOverviewParams struct {
	OrgID    int32  `json:"org_id"`
	Category string `json:"category"`
	After    string `json:"after"`
}

type GetEventsOverviewRow struct {
	ID       int32            `json:"id"`
	OrgID    int32            `json:"org_id"`
	Title    string           `json:"title"`
	Start    pgtype.Timestamp `json:"start"`
	Category pgtype.Text      `json:"category"`
	OrgCode  pgtype.Text      `json:"org_code"`
}

func (q *Queries) GetEventsOverview(ctx context.Context, arg GetEventsOverviewParams) ([]GetEventsOverviewRow, error) {
	rows, err := q.db.Query(ctx, getEventsOverview, arg.OrgID, arg.Category, arg.After)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsOverviewRow
	for rows.Next() {
		var i GetEventsOverviewRow
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Title,
			&i.Start,
			&i.Category,
			&i.OrgCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgsOverview = `-- name: GetOrgsOverview :many
SELECT id, "name" FROM "organization"
ORDER BY code ASC
`

type GetOrgsOverviewRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetOrgsOverview(ctx context.Context) ([]GetOrgsOverviewRow, error) {
	rows, err := q.db.Query(ctx, getOrgsOverview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrgsOverviewRow
	for rows.Next() {
		var i GetOrgsOverviewRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByKerb = `-- name: GetUserByKerb :one
SELECT id, created_at, updated_at, kerb, email, phone, department, class_year, gender, residence, legacy, org_id, is_admin, bid_status, race, first_gen, name FROM "user"
WHERE kerb=$1 LIMIT 1
`

func (q *Queries) GetUserByKerb(ctx context.Context, kerb string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByKerb, kerb)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Kerb,
		&i.Email,
		&i.Phone,
		&i.Department,
		&i.ClassYear,
		&i.Gender,
		&i.Residence,
		&i.Legacy,
		&i.OrgID,
		&i.IsAdmin,
		&i.BidStatus,
		&i.Race,
		&i.FirstGen,
		&i.Name,
	)
	return i, err
}
